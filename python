import time
import subprocess
import serial
import RPi.GPIO as GPIO
import paho.mqtt.client as mqtt
import base64
import os
import glob

# --- Configuration ---
AIO_USERNAME = "Jonalli0124"
AIO_KEY = "6c8ce060af344d95afc44350ecfd279d"

# Feed Names
T_HEATER = f"{AIO_USERNAME}/feeds/relay-heater"
T_TUNNEL = f"{AIO_USERNAME}/feeds/tunnel"
T_CAMERA = f"{AIO_USERNAME}/feeds/camera"
T_IP     = f"{AIO_USERNAME}/feeds/ip-address"
T_SIGNAL = f"{AIO_USERNAME}/feeds/signal"
T_CPU    = f"{AIO_USERNAME}/feeds/temp-1" # CPU
T_TEMP1  = f"{AIO_USERNAME}/feeds/temp-2" # Ambient
T_TEMP2  = f"{AIO_USERNAME}/feeds/temp-3" # Heater
T_TIMER  = f"{AIO_USERNAME}/feeds/timer"  # 10th Feed for Scheduling

# Timing
HEARTBEAT_INTERVAL = 60          # 1 minute
PHOTO_INTERVAL = 4 * 60 * 60     # 4 hours

# Schedule State (Default: All OFF)
# Format: DEVICE, START, STOP, ENABLED
current_sched = {"device": "HEATER", "start": 0, "stop": 0, "enabled": 0, "mode": 1}

# GPIO Setup
RELAY_PIN = 17
GPIO.setwarnings(False)
GPIO.setmode(GPIO.BCM)
GPIO.setup(RELAY_PIN, GPIO.OUT)

last_relay_state = None

# --- Hardware Helpers ---

def initialize_cellular():
    print("üöÄ Initializing Cellular Modem...")
    try:
        # 1. Reset interface
        subprocess.run("sudo ip link set wwan0 down", shell=True)
        subprocess.run("echo 'Y' | sudo tee /sys/class/net/wwan0/qmi/raw_ip", shell=True)
        subprocess.run("sudo ip link set wwan0 up", shell=True)

        # 2. Raw Serial Dial (Avoids shell escaping issues)
        ser = serial.Serial("/dev/ttyUSB2", 115200, timeout=1)
        ser.write(b'AT+CGDCONT=1,"IP","soracom.io"\r\n')
        time.sleep(1)
        ser.write(b'AT$QCRMCALL=1,1\r\n')
        time.sleep(2)
        ser.close()

        # 3. Request IP Address
        print("üõ∞ Requesting IP address...")
        subprocess.run("sudo udhcpc -i wwan0 -n -T 5 -q", shell=True)
        print("‚úÖ Cellular Logic Complete.")
    except Exception as e:
        print(f"‚ùå Cellular Error: {e}")

def get_ds18b20_temps():
    """Reads 1-Wire sensors and returns Fahrenheit values."""
    temps = []
    device_folders = glob.glob('/sys/bus/w1/devices/28*')
    for folder in device_folders:
        try:
            with open(folder + '/w1_slave', 'r') as f:
                lines = f.readlines()
                if lines[0].strip().endswith('YES'):
                    msg = lines[1].find('t=')
                    if msg != -1:
                        temp_c = float(lines[1][msg+2:]) / 1000.0
                        temps.append(round((temp_c * 9/5) + 32, 2))
        except: continue
    while len(temps) < 2: temps.append(0.0)
    return temps[:2]

def capture_and_send_photo(client):
    img_path = "/dev/shm/snap.jpg"
    try:
        # Kill any hung camera processes aggressively
        subprocess.run("sudo pkill -9 rpicam", shell=True, stderr=subprocess.DEVNULL)
        time.sleep(1) # Give the hardware a second to reset

        # Use a shell=False and set a strict timeout
        subprocess.run([
            "rpicam-jpeg", "-o", img_path, "-t", "1000",
            "--width", "800", "--height", "600",
            "--quality", "25", "--nopreview"
        ], check=True, timeout=10) # 10 seconds max!

        if os.path.exists(img_path):
            with open(img_path, "rb") as f:
                encoded = base64.b64encode(f.read()).decode('utf-8')
            client.publish(T_CAMERA, encoded)
            os.remove(img_path)
            print("üì§ Photo Sent")
    except Exception as e:
        print(f"‚ùå Camera failed but script will continue: {e}")

def initialize_cellular():
    print("üöÄ Initializing Cellular Modem...")
    try:
        # ... (keep your existing reset and serial dial code) ...

        # 3. Request IP Address
        print("üõ∞ Requesting IP address...")
        subprocess.run("sudo udhcpc -i wwan0 -n -T 5 -q", shell=True)
        
        # --- ADD THIS LINE HERE ---
        subprocess.run("echo 'nameserver 8.8.8.8' | sudo tee /etc/resolv.conf", shell=True)
        # --------------------------

        print("‚úÖ Cellular Logic Complete.")
    except Exception as e:
        print(f"‚ùå Cellular Error: {e}")

def get_ip_address():
    try:
        output = subprocess.check_output("ip route get 8.8.8.8", shell=True).decode()
        parts = output.split()
        if "src" in parts: return parts[parts.index("src") + 1]
        return "No Route"
    except: return "Offline"

def get_cpu_temp():
    try:
        with open("/sys/class/thermal/thermal_zone0/temp", "r") as f:
            return round((int(f.read()) / 1000.0 * 9/5) + 32, 1)
    except: return 0.0

# --- MQTT CALLBACKS ---

def on_connect(client, userdata, flags, rc, properties=None):
    print(f"‚úÖ Connected to Adafruit (Code: {rc})")
    for t in [T_HEATER, T_TUNNEL, T_CAMERA, T_TIMER]:
        client.subscribe(t)
    
    # --- ADD THIS LINE HERE ---
    # This forces the dashboard to sync with the actual state of the service at boot
    client.publish(T_TUNNEL, "ON")
    print("üöÄ Startup Sync: Tunnel set to ON")

def on_message(client, userdata, msg):
    global current_sched, last_relay_state
    payload = msg.payload.decode()
    topic = msg.topic


    # 1. Master Schedule (Handles both 4-part and 5-part strings)
    if topic == T_TIMER:
        try:
            # .strip() removes any hidden spaces or newlines at the ends
            clean_payload = payload.replace('"', '').strip()
            parts = clean_payload.split(':')
            
            if len(parts) >= 4:
                # Adding .strip() here is the "Safety Net"
                current_sched["device"]  = parts[0].upper().strip()
                current_sched["start"]   = int(parts[1])
                current_sched["stop"]    = int(parts[2])
                current_sched["enabled"] = int(parts[3])
                
                if len(parts) == 5:
                    current_sched["mode"] = int(parts[4])
                else:
                    current_sched["mode"] = 1 
                
                print(f"üìÖ Schedule Updated: {current_sched}")
        except Exception as e:
            print(f"‚ùå Schedule Format Error: {e}")
    # 2. Relay Switch (With Loop Protection)
    elif topic == T_HEATER:
        new_state = payload.upper()
        
        # SMART CHECK: Only disable schedule if the incoming message 
        # is DIFFERENT from what the Pi just set the relay to.
        if new_state != last_relay_state:
            if current_sched["enabled"] == 1:
                current_sched["enabled"] = 0
                # Sync 'disabled' back to Adafruit so the dashboard button turns grey
                sync_payload = f"{current_sched['device']}:{current_sched['start']:04d}:{current_sched['stop']:04d}:0"
                client.publish(T_TIMER, sync_payload)
                print(f"‚ö†Ô∏è Manual override detected ({new_state}). Auto-Schedule disabled.")

            # Physically apply the state change
            GPIO.output(RELAY_PIN, GPIO.HIGH if new_state == "ON" else GPIO.LOW)
            last_relay_state = new_state
            print(f"üî• Relay set to: {new_state}")
        else:
            # If the state matches, it was likely an echo of the Pi's own command.
            # We ignore it to keep the schedule alive.
            print(f"‚ôªÔ∏è Echo received ({new_state}). Schedule preserved.")

    # 3. Cloudflare Tunnel
    elif topic == T_TUNNEL:
        action = "start" if payload == "ON" else "stop"
        try:
            subprocess.run(["sudo", "systemctl", action, "cloudflared"], check=True)
            print(f"üõ† Tunnel: {action.upper()}")
        except Exception as e:
            print(f"‚ùå Tunnel Error: {e}")

    # 4. Manual Camera Trigger
    elif topic == T_CAMERA and payload == "SNAP":
        capture_and_send_photo(client)

# --- MAIN LOOP ---

time.sleep(30)
initialize_cellular()

client = mqtt.Client(mqtt.CallbackAPIVersion.VERSION2)
client.username_pw_set(AIO_USERNAME, AIO_KEY)
client.on_connect = on_connect
client.on_message = on_message

try:
    client.connect("io.adafruit.com", 1883, 60)
    client.loop_start()
    
    # Initialize state tracking
    # Setting last_relay_state to None forces the Pi to sync on the very first loop
    last_photo_time = 0
    last_relay_state = None 
    
    print("üöÄ System Online. Press Ctrl+C to stop.")

    while True:
        now_ts = time.time()
        
        # 1. Schedule Logic (Adaptive & Device-Aware Mode)
        if current_sched["enabled"] == 1:
            current_time_int = int(time.strftime("%H%M"))
            start = current_sched["start"]
            stop = current_sched["stop"]
            
            # Step A: Determine if we are in window (Handles Overnight Wrap-Around)
            if start <= stop:
                # Normal window (e.g., 0800 to 1700)
                in_window = start <= current_time_int < stop
            else:
                # Overnight window (e.g., 2100 to 0600)
                in_window = current_time_int >= start or current_time_int < stop
            
            # Step B: Determine if the device SHOULD be "Active"
            # Mode 1: Active inside window | Mode 0: Active outside window
            should_be_active = in_window if current_sched["mode"] == 1 else not in_window

            # Step C: Translate "Active" to Physical Relay & Status Text
            # HEATER: Active = HIGH (Dashboard ON)
            # AC:     Active = LOW  (Dashboard OFF)
            if current_sched["device"] == "HEATER":
                desired_relay = GPIO.HIGH if should_be_active else GPIO.LOW
                status_text = "ON" if should_be_active else "OFF"
            else:
                # Logic for AC Unit (Inverted Hardware)
                desired_relay = GPIO.LOW if should_be_active else GPIO.HIGH
                status_text = "OFF" if should_be_active else "ON"

            # Step D: Update Hardware and Adafruit only on state changes
            if status_text != last_relay_state:
                GPIO.output(RELAY_PIN, desired_relay)
                client.publish(T_HEATER, status_text)
                last_relay_state = status_text
                print(f"üìÖ {current_sched['device']} is now {status_text} (In Window: {in_window})")

        # 2. Heartbeat (System Telemetry)
        try:
            # Send the ACTUAL time to the dashboard clock
            client.publish(T_SIGNAL, time.strftime("%H:%M:%S"))
            
            # Send other system health data
            client.publish(T_IP, get_ip_address())
            client.publish(T_CPU, get_cpu_temp())
            
            # Send Temperature Probes
            probes = get_ds18b20_temps() 
            if len(probes) >= 2:
                client.publish(T_TEMP1, probes[0])
                client.publish(T_TEMP2, probes[1])
                
        except Exception as e:
            print(f"‚ö†Ô∏è Telemetry Error: {e}")

        # 3. Photo Logic
        if now_ts - last_photo_time >= PHOTO_INTERVAL:
            try:
                capture_and_send_photo(client)
                last_photo_time = now_ts
            except Exception as e:
                print(f"üì∏ Camera Error: {e}")

        # Governs loop speed (Interval defined at top of script, e.g., 60s)
        time.sleep(HEARTBEAT_INTERVAL)

except KeyboardInterrupt:
    print("\nüõë Manual shutdown initiated.")
except Exception as e:
    print(f"üí• Critical System Error: {e}")
finally:
    # Cleanup ensures the relay is released and GPIO pins are reset
    client.loop_stop()
    client.disconnect()
    GPIO.cleanup()
    print("üëã Cleanup complete. Pi is safe.")
